---
description: Architectural patterns for MongoDB library design
alwaysApply: true
---

# Architecture Patterns

## Singleton Pattern (Detected in Codebase)

### Implementation
- Private constructor to prevent direct instantiation
- Static instance property to hold single instance
- Static getInstance() method for access
- Stateful properties (client, db) managed internally

### Example Structure
```typescript
class ServiceClass {
    private static instance: ServiceClass;
    private client: MongoClient | null = null;

    private constructor() {}

    static getInstance(): ServiceClass {
        if (!ServiceClass.instance) {
            ServiceClass.instance = new ServiceClass();
        }
        return ServiceClass.instance;
    }
}
```

## Connection Management

### Lifecycle Pattern
1. **Connect**: Establish connection with URI and optional database
2. **SetDB**: Select specific database to work with
3. **Operations**: Perform CRUD operations
4. **Close**: Clean up and close connection

### State Validation
- Check connection state before operations
- Throw descriptive errors if not connected
- Allow reconnection by closing previous connection
- Nullify state on close for clean reset

## Generic CRUD Operations

### Type Safety
- Use TypeScript generics for all CRUD methods
- Extend MongoDB's Document type for type constraints
- Return typed results (e.g., `WithId<T>`)
- Accept typed filters and queries

### Method Patterns
- **getOne**: Query with Filter<T>, return WithId<T> | null
- **getMany**: Query with Filter<T> and QueryOptions (limit, skip, sort), return WithId<T>[]
- **createOne**: Accept new document, validate uniqueness, return WithId<T>
- **createMany**: Bulk insert with partial failure handling, return BulkCreateResult<T>
- **updateOne**: Require _id, accept partial updates, return updated WithId<T>
- **updateMany**: Update multiple documents, return update count
- **deleteOne**: Require _id, return boolean success
- **deleteMany**: Delete multiple documents, return delete count

### Bulk Operations
- Support partial success with `BulkCreateResult<T>` type
- Return both successful insertions and failures
- Include error information for failed documents
- Handle `MongoBulkWriteError` appropriately
- Example return structure:
  ```typescript
  interface BulkCreateResult<T> {
    inserted: WithId<T>[];
    failed: Array<{ document: T; error: Error }>;
  }
  ```

### ObjectId Handling
- Accept both string and ObjectId for _id fields
- Use utility function `toObjectId()` for conversion with validation
- Throw `InvalidObjectIdError` for invalid formats
- Use consistent pattern across all methods:
  ```typescript
  import { toObjectId } from './utils';

  const objectId = toObjectId(_id); // Validates and converts
  const query = { _id: objectId };
  ```

### Retry Pattern
- Use `withRetry()` utility for resilient operations
- Configure retry options (maxAttempts, baseDelayMs, maxDelayMs)
- Implement exponential backoff strategy
- Apply to connection operations and critical database calls
- Example:
  ```typescript
  await withRetry(async () => {
    // operation that may fail transiently
  }, { maxAttempts: 5, baseDelayMs: 1000 });
  ```

### Validation Pattern
- Use assertion utilities for input validation
- `assertNotEmpty(value, fieldName)` - ensures value is not null/undefined/empty
- `assertRequired(value, fieldName)` - ensures value exists
- Throw `ValidationError` with descriptive messages
- Validate before database operations to fail fast

## Library Design Principles

### Public API
- Export singleton instance for consumer convenience
- Keep interface simple and intuitive
- Use descriptive method names
- Provide type definitions for consumers

### Internal Implementation
- Keep state private
- Validate inputs before operations
- Provide helpful error messages
- Log operations for debugging

### Database Abstraction
- Simplify MongoDB driver complexity
- Provide opinionated CRUD interface
- Handle common patterns (unique field validation, _id conversion)
- Return clean, typed results